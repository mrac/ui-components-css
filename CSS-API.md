# Component CSS API

## Elements and states

Components should provide a way to set up CSS for their root element, internal elements and possible states (modifiers). States are variant CSS definitions used conditionally inside a component.

### Elements and states - namespacing

The simplest solution would be to use semantic `CSS` classes, with proper namespacing ([BEM](https://en.bem.info/methodology/quick-start/) for naming is just one possible convention). With CamelCased component names in React applications a simpler variant of `CSS` classes convention would be more useful:
* `ComponentName` - for the root element
* `ComponentName-elementName` - for any internal element with UI-importance
* `ComponentName_stateName` - for any component state with potential UI-importance
* `ComponentName-elementName_stateName` - for any element state with potential UI-importance

Element-name and state-name should be defined according to their functions, not to their visual presence (e.g. `MyInput-reset` instead of `MyInput-button_red`). Why functional names for CSS classes? Because:
* it's not a job of a component to define its look
* it decouples `HTML` template structure from `CSS API`
    * both can be modified separatelly without affecting each other - makes the code more clear and scalable
    * internal `HTML` structure is not a part of component API, it's an implementation detail and can changed without breaking the API

### Elements and states - other implementations

Namespacing doesn't really solve problems absolutly, because those are still global CSS clasess, so:
- there is still possibility to use the same name for different component
- they still can be overwritten globally, even in unrelated code
- they may be used outside of its context
- they don't require to declare CSS dependency explicitly

There are other solutions that make selectors local, like e.g.:
- [CSS modules](https://github.com/css-modules/css-modules)
- [styled components](https://github.com/styled-components/styled-components) (or its variants)
- [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)

There is also [Stylable](https://stylable.io/) which uses their own `CSS` syntax extension to define elements and states (custom `pseudo-elements` and custom `pseudo-classes`).

But for the purpose of this research let's use "vanilla" namespacing solution, because of its flexibility.

### Selectors

Any element inside any component may be targeted by the parent using a selector which is combined of a few dimensions:
* its component instance CSS class (optional, e.g. `Parent-element1`)
* its component type CSS class (e.g. `Component`)
* its element/state CSS class (e.g. `Component-element1` or `Component_state1` or `Component-element1_state1`)

For example when setting the external layout of a `Component`:
```css
.Parent {}
.Parent .Parent-element1.Component {}
```

For example when customising the internal layout of a `Component`:
```css
.Parent .Parent-element1.Component .Component-element1 {}
.Parent .Parent-element1.Component .Component-element2 {}
```

Looking from the application level, e.g. when setting the look of a `Component`:
```css
.App.appTheme1 .Component .Component-element1 {}
```

Setting the look of a `Parent`:
```css
.App.appTheme1 .Parent {}
.App.appTheme1 .Parent .Parent-element1.Component {}
.App.appTheme1 .Parent .Parent-element1.Component_state1 {}
.App.appTheme1 .Parent .Parent-element1.Component .Component-element1_state1 {}
```

* ([see example](CSS-RESPONSIBILITY.md#components-are-not-responsible-for-their-look))

Using any selectors relying on `HTML` tags like tag names, ids, attributes other than `component`/`element`/`state` would be considered unsafe, and vulnerable to breaking.

Autogenerated elements should also provide a semantic class including their id, as targetting them by their order (`:nth-child`) would not be safe.

However, using any pseudo-selectors that doesn't rely on the `HTML` structure would be considered safe, like:
- `:not`
- `:hover`
- `:active`
- `:focus`
- `:enabled`
- `:disabled`
- `:checked`
- `:inteterminate`
- `::first-letter`
- `::first-line`

## Properties

Although selectors may be accessible on every level of components hierarchy, that's not the case for `CSS` properties.
According to [component responsibility](CSS-RESPONSIBILITY.md), component API should be divided into:

* &#x1F4D7; **Look** `CSS` properties on all elements - can be set safely by all ancestors ([list](CSS-RESPONSIBILITY.md#look))
* &#x1F4D9; **External-layout** `CSS` properties on the root element - can be set safely by the component's parent ([list](CSS-RESPONSIBILITY.md#external-layout-properties))
* &#x1F4D5; **Internal-layout** `CSS` properties can be only set safely by component itself - on the root element ([list](CSS-RESPONSIBILITY.md#internal-layout-properties)) and all children elements ([list](CSS-RESPONSIBILITY.md#layout))
* `display` property is an exception and may have different access rights (&#x1F4D5; or &#x1F4D9;), based on its value ([see](CSS-RESPONSIBILITY.md#display-property)) compared to default value in the component's root

## Semantic versioning

Whenever a UI-component library is updated, the updated version should reflect [semver](https://semver.org/) convention:
* MAJOR version when you make incompatible API changes,
* MINOR version when you add functionality in a backwards-compatible manner, and
* PATCH version when you make backwards-compatible bug fixes.

Therefore it is critical to establish and define the full API, including `CSS` code.

### Major version

MAJOR version should be considered, whenever any of the following `CSS` part has been MODIFIED or REMOVED:
- **component** CSS class name or its meaning
- **element** CSS class name or its meaning
- **state** CSS class name or its meaning

also whenever any of the following `CSS` properties has been MODIFIED, REMOVED or ADDED:
- look CSS default properties
- external-layout CSS default properties

also whenever `HTML` template has been MODIFIED causing implicit changes in look-CSS default properties.

> For example: changing `HTML` template from:
> * `<a class="Component-submit">OK</a>`
> to:
> * `<button class="Component-submit">OK</button>`
> 
> without any `CSS` precautions or adjustments, will change `color` property value for `Component-sumbit` from `inherit` to `black`).

### Minor version

MINOR version should be considered, whenever any of the following `CSS` part has been ADDED:
- new **component** with its CSS class name
- new **element** with its CSS class name
- new **state** with its CSS class name

also whenever any of the following `CSS` properties has been MODIFIED, REMOVED or ADDED for the purpose of a new feature:
- internal-layout CSS properties

### Patch version

PATCH version should be considered for all other cases, which may happen whenever `CSS` properties has been MODIFIED, REMOVED or ADDED for the purpose of bug-fixing the existing features:
- internal-layout CSS properties







